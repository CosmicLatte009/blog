# Next.js 튜토리얼 온보딩으로 SSR 이해도 높이기

사이드프로젝트에서 Next.js를 사용하고 있다. 기술 선정 이유가 라우팅을 폴더로 편하게 해보자...였는데 점점 거의다 만들어갈 수록 이 프로젝트가 과연 Next.js를 잘 사용하고 있는지 의문이 들기 시작했다. SSR도 잘 쓰고 있는 것 같지 않았다.🥹 Next.js에 대해 잘 공부하고 들어가지 않은 프로젝트라 영 찜찜하다. 리팩토링하기 좋은 순간이란 뜻이다. 제주코딩베이스캠프의 친절한 넥스트 튜토리얼 온보딩 무료 강의를 통해 Next.js과 멀어지지 말고 다시 친해져보자.

[![넥스트 튜토리얼 온보딩](https://github.com/user-attachments/assets/8b95861d-f003-4239-8ef0-b662a3f05302)](https://www.youtube.com/watch?v=OMhta0RbzV4)

## 동적 라우팅

#### Next.js에서의 동적 라우팅하는 방법

```tsx
/**app 폴더 > product 폴더 > [id] 슬러그 > page.tsx**/

export default function ProduectDetails(props) {
	return (
		<div>
			<h1>ProductDetails</h1>
			<p>parameters: {props.params.id}</p>
		</div>
	);
}
```

#### 동적 라우팅은 사실 상태관리로 기능한다

맨날천날 헷갈리는 동적 라우팅.
라우팅..은 페이지 간 이동할 수 있게 설정해주는거 아닌가...라는 생각을 벗어나지 않으니 라우팅이 애플리케이션의 상태관리 도구로 기능한다는 것을 종종 망각한다.

이렇게 동적 라우팅을 사용하면 URL을 통해 애플리케이션의 상태를 표현함으로써 저장, 공유 용이성, 브라우저의 히스토리 기능과도 자연스럽게 통합할 수 있다.이는 SEO 최적화에도 유리하다. 서버 사이드 렌더링 시 초기 상태로 활용할 수도 있다.

## API를 활용한 데이터 로딩

#### CSR

주로 fetch로 데이터를 불러와 렌더링하는 React와 같은 CSR.

1. API 라우트 설정한 파일 생성. (api 요청하는 함수)
2. 컴포넌트 안에서 API 데이터를 가져오게끔한다. 클라이언트가 렌더링하게 하려면 상단에 `use client`를 사용해준다.
   사용자의 반응을 봐야할 때는 특히 use client를 사용한다.

클라이언트 컴포넌트, 즉 클라이언트에서 JavaScript에 의해 렌더링되는 컴포넌트. 실시간 업데이트에 적합한 컴포넌트에서 사용한다고 보면 된다.

#### SSR

미리 렌더된 내용을 받아와서 뿌려주는 것.

1. fetch를 컴포넌트 밖에서 해준다. (백엔드 서버에서 fetch를 날려서 데이터를 완성해서 완전히 HTML로 변환하고 클라이언트에 전달한다.)
2. 컴포넌트에서 받아온 완성된 데이터를 UI에 뿌려주기만 한다.

서버 컴포넌트, 즉 클라이언트에 전달되기 전에 서버에서 렌더링되어 완전히 HTML로 변환된 컴포넌트인 것이다. 클라이언트는 단순히 이미 렌더링된 HTML을 받아서 표시하기만 할 수 있다.

CSR에서는 [크롬 개발자 도구]-[네트워크탭]에서 fetch를 확인할 수 있지만 SSR의 경우엔 fetch 대신 [document]를 확인 가능하다.
하지만 내가 사이드프로젝트에서 작업한 것처럼 제대로 SSR을 사용하지 못하면 아래처럼 완성된 HTML이 아닌 프로필 이미지가 깨진 이런 document를 받아보게 되는 것이다...

![하루강아지 document](https://github.com/user-attachments/assets/8426a211-cfc0-4317-9257-ab8cc27c702a)

## 사실 SSR이 먼저였다

내가 React가 제일 유명한 때에 코딩을 시작해서 그런지, Next.js를 처음 봤을 때만 해도 CSR이 기본이지만, SSR을 추가적으로 사용해야한다는 생각을 했던 것 같다.
사실은 React 공식문서의 [renderToString](https://react.dev/reference/react-dom/server/renderToString)과 같은 전통적인 서버 사이드 함수로 React 컴포넌트를 HTML 문자열로 렌더링하는 것이 오히려 먼저 있는 방식이었다.

React renderToStrng은 통한 SSR은 아래처럼 이루어진다.

1. 서버에서 React 컴포넌트를 renderToString으로 HTML로 변환
2. 생성된 HTML을 클라이언트에 전송
3. 클라이언트에서 JavaScript를 로드하고 이벤트 핸들러를 연결 (hydration)

하지만 페이지 전환마다 전체 페이지를 다시 로드해야하고, 무엇보다 동적 콘텐츠 변경이 어려웠다. 그래서 CSR이 등장하고서야 단일 페이지 애플리케이션(SPA)가 가능해졌고, 앱과 유사한 웹 경험을 제공할 수 있게 되었다. 하지만 CSR은 또 초기 로딩 시간이 길어지고 SEO에 불리하니...Next.js같은 SSR과 CSR을 둘다 사용할 수 있는 프레임워크가 등장한 것이다.

## 그래서 어떻게 CSR, SSR을 혼합해서 사용하나?

나는 예전에는 CSR과 SSR을 혼합해서 사용할 수 있다는 말을, 전체 애플리케이션에서는 혼합할 수 있되 한 페이지 당 반드시 하나의 접근법을 채택해야하는 것으로 이해했다.
하지만 사실은 한 페이지 안에서도 유연하게 혼합해서 사용할 수 있다.
예를 들어, 제품 상세 페이지가 있다고 치면, 초기 로딩은 SSR로, 이후 상호작용은 CSR를 통해 처리할 수 있다.

1. 초기 렌더링 (SSR): 제품의 기본 정보, 설명, 이미지 URL 등은 SSR로 처리합니다. 이는 SEO에 유리하고 초기 로딩 속도를 개선.

2. hydration: 클라이언트 측에서 자바스크립트가 로드되면, React가 서버에서 렌더링된 HTML에 이벤트 리스너를 연결.

3. 상호작용 (CSR): 사용자 리뷰 작성, 장바구니 추가, 옵션 선택 등의 동적 기능은 CSR로 처리

4. 데이터 업데이트: tanstack-query나 SWR과 같은 라이브러리를 사용하여 필요한 시점에 데이터를 리페치

> 리페치 시점은?
>
> - 주기적 업데이트: 일정 간격으로 자동 리페치
> - 포커스 시: 사용자가 탭/창으로 돌아올 때
> - 재연결 시: 네트워크 연결이 복구될 때
> - 수동 트리거: 사용자가 '새로고침' 버튼을 클릭할 때

## TanStack Query가 그렇게 핫한 이유가...

TanStack Query의 캐싱도 쓰면 SSR과 CSR, SPA의 장점을 모두 활용할 수 있다.

#### 1. 초기 데이터 로딩 (SSR + TanStack Query)

페이지의 초기 상태를 서버에서 렌더링.
TanStack Query를 사용하여 이 데이터를 클라이언트에서 관리.
`getServerSideProps`를 통해 초기 사용자 데이터를 서버에서 가져오는 등

#### 2. 데이터 갱신 (TanStack Query)

클라이언트에서 주기적으로 또는 특정 이벤트에 따라 데이터를 갱신
`useQuery` 훅을 사용하여 클라이언트에서 이 데이터를 관리하고 필요시 갱신.

#### 3. 사용자 상호작용 (CSR)

POST, PUT 등의 변경 작업은 클라이언트에서 처리
편집 모드에서는 `useMutation` 훅을 사용하여 사용자 데이터 업데이트를 처리
