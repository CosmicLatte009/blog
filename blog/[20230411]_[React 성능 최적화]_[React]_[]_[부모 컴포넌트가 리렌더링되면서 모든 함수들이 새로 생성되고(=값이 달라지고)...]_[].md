# React 성능 최적화

> 부모 컴포넌트가 리렌더링되면서 모든 함수들이 새로 생성되고(=값이 달라지고) 불필요해도 이펙트와 자식 컴포넌트가 재실행되는 문제점을 해결하기 위해 성능 최적화를 해준다. 특히 React.memo와 useCallback()을 통해 또다른 무한루프를 막는다.

성능 최적화에는 비용이 따른다.  
성능 효율은 어떤 컴포넌트를 최적화하느냐에 따라 달라질 수 있다.  
아주 간단한 컴포넌트의 경우, 성능 최적화 기능을 추가하지 않는게 나을 수도 있다.

### 리렌더링 VS 성능 최적화

무분별하게 성능 최적화 기능을 사용하면 리액트가 항상 props의 변경사항을 확인해야하기 때문에 변경사항 확인보다 리렌더링이 더 빠를 수도 있다.

리렌더링은 가상DOM을 대상으로 이루어지기 때문에 변경이 생겼을 때 무조건 실제 DOM을 다시 그리는게 아니다.  
그러므로 무조건적인 성능 최적화보다 리렌더링이 나을 수도 있는 것이다.

---

# React.memo

불필요한 재실행을 막아주는 함수형 컴포넌트 최적화 기능.  
함수형 컴포넌트에서만 사용 가능.  
props가 변경된 경우에만 컴포넌트 재실행.  
props가 변경되지 않았다면 컴포넌트 재실행 건너뛴다.

### 사용법

`export default React.memo(컴포넌트명)`

### 작동 원리

1. React.memo가 적용된 컴포넌트에 전달되는 모든 props의 신규 값을 확인한 뒤  
   기존의 props값과 비교하도록 리액트에게 전달.
2. props의 값이 바뀐 경우에만 컴포넌트 재평가, 재실행
3. 부모 컴포넌트가 변경되어도 React.memo가 적용된 자식 컴포넌트의 props값이 바뀌지 않았다면 컴포넌트 실행 건너뛴다.  
   React.memo가 적용된 자식 컴포넌트의 자식 컴포넌트 또한 재실행을 건너뛴다.

### React.memo 예시

name props로 받아와 출력하는 간단한 컴포넌트.

```JSX
import React from 'react';

const MyComponent = React.memo(({ name }) => {
  console.log('Rendering MyComponent');
  return <div>{name}</div>;
});

```

React.memo를 사용하여 컴포넌트를 감싸면,  
name이 변경되지 않는 한 같은 결과를 가진 이전의 렌더링 결과가 재사용된다.  
따라서 name이 변경되지 않는 한, 해당 컴포넌트는 다시 렌더링되지 않는다.

### React.memo가 유용한 경우

큰 규모의 작업에서 불필요한 재렌더링을 막을 때.  
컴포넌트 트리에서 잘라낼 수 있는 몇가지 주요 컴포넌트 선택해서 사용하면 된다.

### React.memo가 필요하지 않은 경우

작은 규모의 직업에서 props를 비교하는 성능 비용이 컴포넌트 재실행하는 성능 비용보다 많이 들 것 같을 때.  
변경이 발생할 때마다 해당 컴포넌트로 이동하여 기존 props값과 새로운 값을 비교해야한다.  
기존의 props값을 저장한 공간, 비교하는 작업을 위해 개별적인 성능 비용이 필요하다.

### props 값이 객체 타입인 경우

전달받는 props의 데이터 타입이 객체 타입인 컴포넌트의 경우, props의 데이터 타입이 원시값(true === true) 인 경우와 다르게  
**참조형([1,2,3] !== [1,2,3]) 특성 때문에**
기존의 props와 신규 props 값을 비교할 때 props 값이 변경되었다고 인식한다.  
때문에 React.memo 적용에도 불구하고 컴포넌트 재평가, 재실행이 이루어진다.

이를 해결하기 위해 `useCallback()`이나 `useMemo()`를 사용한다.

---

# useCallback()

useCallback에 래핑된 함수를 캐싱(cache)하여 컴포넌트 재렌더링 후에도 남아있게 한다.

동일한 함수 객체가 메모리의 동일한 위치에 저장되므로 객체 타입끼리도 비교 작업이 가능해진다.  
컴포넌트 실행 전반에 걸쳐 props에 함수를 저장할 수 있게 한다.  
즉, props값이 객체 타입인 경우에도 props 간 비교가 가능해지니까, `React.memo` 사용하여 불필요한 재실행도 막을 수 있다.

### 사용법

1. `import React, {useCallback} from 'react'`
2. `const 변수명 = useCallback(() => {}, [])`

- 첫번째 인수
  `()=>{}` 와 같은 함수를 전달하면 useCallback에서 저장된 해당 함수를 반환.  
   래핑한 함수를 리액트의 내부 저장 공간에 저장해서 함수 객체가 실행될 때마다 재사용할 수 있게 된다.
- 두번째 인수
  의존성 배열.

### useCallback 예시

onClick 이라는 콜백 함수를 props로 받아와 버튼이 클릭되었을 때 호출하는 컴포넌트.

```JSX
import React, { useCallback } from 'react';

const MyComponent = ({ onClick }) => {
  const handleClick = useCallback(() => {
    console.log('Button clicked');
    onClick();
  }, [onClick]);

  return <button onClick={handleClick}>Click me</button>;
};
```

useCallback을 사용하여 handleClick 함수를 감싸면,  
onClick이 변경되지 않는 한 동일한 함수 인스턴스가 재사용된다.  
따라서 onClick이 변경되지 않는 한, handleClick 함수는 다시 생성되지 않는다.

### useCallback이 유용한 경우

어떤 함수가 절대 변경되면 안될 때 useCallback으로 래핑해주면 된다.  
컴포넌트 재평가, 재실행 시 useCallback이 React가 저장한 함수
(useCallback으로 래핑한 함수)를 찾아서 같은 함수 객체를 재사용한다.

### 의존성 배열

의존성 배열에는 상태나 props, 컨텍스트를 지정할 수 있다.  
외부에서 가져온 변수(상수)를 최신 값으로 유지하기 위해 사용한다.  
외부에서 가져온 값이 변경되면 함수를 재생성하고 새로 만든 함수를 저장한다.  
그렇지 않으면, 저장한 함수를 계속 쓴다.

#### 의존성으로 추가할 항목

컴포넌트 함수에 정의된 변수, state, props, 함수.  
 `useCallback()` 함수에서 사용하는 모든 '것들'.

ex) `[setState]`  
 함수는 호출하지 않고 포인터만 넣는다.

#### 의존성이 불필요한 경우

React가 `useCallback()`을 통해 해당 함수가 절대 바뀌지 않으며 이전과 동일한 함수 객체임을 보장하므로 아주 짧고 간단한 코드의 경우엔 의존성이 불필요하다.

#### 의존성이 지정되지 않은 경우

컴포넌트가 다시 렌더링되어도 항상 같은 함수 객체가 사용되게끔 한다.  
 함수가 재실행되어도 특정 의존성이 변경되는 것이 아니면 함수 재생성을 막을 수 있다.

의존성을 지정하지 않아도 `[]` 빈 배열은 필수.  
 React가 변수에 저장하려고 하는 콜백함수는 절대 변경되지 않을거라고  
 React에 알려주는 배열이므로.

### 의존성 배열이 필요한 이유

> 함수가 모든 재렌더링 주기마다 항상 똑같은 로직을 쓰는데, 의존성이 왜 필요할까?

함수가 클로저, 즉 상위 스코프의 식별자를 참조하고 외부 함수보다 오래 유지되고 있는 중첩 함수인 경우,  
함수가 정의될 때 함수 외부에서 가져온 모든 변수를 잠근다.  
즉, JavaScript는 해당 변수들에 클로저를 만들고 함수를 정의할 때 사용하기 위해 변수(상수)를 저장한다.  
다음에 함수가 실행되면 저장된 변수를 그대로 사용하게 되는 것.  
(= 변수가 저장된 시점의 값을 사용하게 되는 것. )

`useCallback()`, `React.memo` 등을 사용하지 않는 경우라면 컴포넌트 재실행 시 함수도 재생성되어서 함수 정의할 때마다 변수값이 자동으로 최신값으로 저장된다.

그런데 `useCallback()`을 통해 어떤 환경에서든 함수 재생성을 하지 않도록 했기 때문에  
**함수에 사용하기 위해 저장한 변수(상수) 값은 최신의 값이 컴포넌트가 처음 실행된 시점의 값으로 저장되는 것.**

그래서 의존성 배열에 외부에서 가져온 값을 넣어주어서 외부에서 가져온 값이 변경되면 함수를 재생성하고, 아니라면 이미 저장된 함수를 계속 쓰도록 한다.

---

# useMemo()

useCallback이 함수에 대한 것을 저장하듯 useMemo는 모든 종류의 데이터를 저장할 수 있어서, 원하는 값을 메모라이징(memorizing)하고,  
컴포넌트가 재렌더링될 때마다 불필요한 데이터 생성이 일어나지 않도록 한다.

### 사용법

1.  `import {useMemo} from 'react';`

2.  `const 변수명 = useMemo(()=>{return 저장할 값},[])`

- 첫번째 인수
  저장된 값을 반환하는 함수.
  함수 자체를 반환하는 것이 아님을 주의.
- 두번째 인수
  의존성 배열.
  지정된 값에 변경사항이 생길 때마다 업데이트된다.

3. `<자식 컴포넌트 props = {useMemo(()=> {return 저장할 값}, [])}/>`
   props값이 객체 타입인 경우, 해당 props값 자체에 useMemo를 사용할 수 있다.

### useMemo 예시

list 라는 숫자 배열을 props로 받아와 배열의 합계를 계산하여 출력하는 컴포넌트.

```JSX
import React, { useMemo } from 'react';

const MyComponent = ({ list }) => {
  const total = useMemo(() => {
    console.log('Calculating total');
    return list.reduce((sum, item) => sum + item, 0);
  }, [list]);

  return <div>Total: {total}</div>;
};

```

useMemo를 사용하여 total 값을 계산하는 함수를 감싸면,  
list가 변경되지 않는 한 같은 입력에 대한 결과는 이전에 계산된 값이 재사용된다.  
따라서 list가 변경되지 않는 한, total값이 다시 계산되지 않는다.

### useMemo가 유용한 경우

복잡한 값에 대한 연산을 수행하느라 시간이 걸리는 경우에 유용하다.  
다음 컴포넌트 재실행할 때에는 의존성 배열의 값이 업데이트되지 않는 한,  
불필요하게 다시 연산하지 않게끔 한다.

사실 데이터 자체를 저장하는 것보다 `useCallback()`처럼 함수를 저장하는 것이  
훨씬 유용해서 `useMemo()`의 사용 빈도수는 낮다.
