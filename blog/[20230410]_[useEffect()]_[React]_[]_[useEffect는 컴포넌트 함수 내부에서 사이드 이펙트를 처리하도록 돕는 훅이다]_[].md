# useEffect()

컴포넌트 함수 내부에서 사이드 이펙트르르 처리하도록 돕는 훅.  
사이드 이펙트를 일으키는 코드가 직접적으로 컴포넌트 함수에 들어가면 안된다.  
버그나 무한 루프가 발생할 가능성이 높기 때문.

기본적으로 useEffect()는, 즉 사이드 이펙트(side Effect)는 컴포넌트의 렌더링이 끝나야 실행된다.  
컴포넌트 재실행될 때마다 끝에 실행되는 함수인 것.  
여러개의 useEffect() 생성 가능.

## 사이드 이펙트(side Effect)

어떤 액션에 대한 응답으로 실행된느 액션이 있다면 곧 사이드 이펙트.  
UI를 렌더하고 입력 값에 반응하는 등 화면에 무언가를 가져오는 역할 외에 애플리케이션에서 일어나는 다른 모든 것을 뜻한다.

- http 리퀘스트 보내기
- 브라우저 저장소에 무언가를 저장하기 (데이터 저장소 접근)
- 코드에서 타이머(setTimeout), 간격 설정하기
- 사용자 입력 데이터의 사이드 이펙트
  - 키 입력을 듣고 입력된 데이터 저장
  - 이메일, 비밀번호 키 입력에 대한 응답으로 해당 폼의 유효성 확인 및 검사

---

## 기본 사용법

`useEffect(()=>{}, [지정된 의존성])`

#### 첫번째 인수

    - 사이드이펙트 함수.
    - 모든 컴포넌트 평가 후 실행되는 함수.
    - 주로 사이드이펙트 코드가 들어간다.
    - `return () => {}`
        - 첫번째 인자에선 함수 자체를 반환할 수 있다.
        - 익명 함수로 쓰는게 보통.
        - Cleanup 함수로서 실행된다.

#### 두번째 인수

- 의존성으로 구성된 배열
- 이 지정된 의존성이 변경되는 경우에만 첫번째 인수의 함수가 다시 실행된다.
- 즉, 함수가 언제 실행될지 제어할 수 있다.

### 의존성으로 추가할 항목

1. 컴포넌트 함수에 정의된 변수, state, props, 함수
2. effect 함수에서 사용하는 모든 '것들'.
3. 구성 요소가 다시 렌더링 되어 이러한 '것들'이 변경될 수 있는 경우.
   ex) `[enteredEmail, enteredPassword]`  
   함수는 호출하지 않고 포인터만 넣는다. `[함수명]`

### 의존성으로 추가하지 않을 항목

#### 1. setState 함수

state 업데이트 함수는 React는 해당 함수가 절대 변경되지 않도록 보장하므로  
 (재렌더링 주기에 따라 변하지 않으므로) 종속성으로 추가할 필요가 없다.

#### 2. 컴포넌트 함수 밖의 변수나 함수

- 함수 또는 변수도 구성 요소 함수 내부에서 생성되지 않으므로 변경해도 구성 요소에 영향을 주지 않는다.
- 해당 변수가 변경되는 경우, 또는 그 반대의 경우에도 구성 요소는 재평가되지 않는다.

#### 3. 내장 API 또는 함수 (fetch, localStorage, setTimeout)

브라우저 API/전역 기능을 React 구성 요소 렌더링 주기와 관련이 없으며 변경되지 않는다.

### 여러개의 의존성이 있는 경우

    - 쉼표로 구분.
    - '또는' 의 의미를 가지므로 하나라도 바뀌면 함수가 실행되고, 하나라도 바뀌지 않으면 실행되지 않는다.

### 의존성이 지정되지 않은 경우

    - 의존성을 지정하지 않아도 `[]` 빈 배열은 필수.
    - 컴포넌트 함수가 처음 실행되는 것을 의존성이 변경된 것으로 간주한다.
    - 이 경우엔, 의존성이 또 변경될 일이 없기 때문에 앱이 시작될 때 useEffect() 함수가 한번만 실행된다.
    - `componentDidMount()` 처럼 동작.

---

## 디바운싱

사용자 입력을 디바운스(그룹화)하는 것.  
사용자가 키 입력을 할 때마다 유효성 검사를 하는게 아니라 사용자가 타이핑을 일시 중지했을 때, 유효성 검사를 하고 싶을테니까.

---

## Cleanup 함수

`useEffect(()=>{return () => {}}, [])`

useEffect의 첫번째 인수인 사이드이펙트 함수에서 return해준다.

#### 실행 시점

- useEffect가 **다음번 새 사이드이펙트 함수 실행하기 전에 실행.**
- 이펙트를 특정한 **컴포넌트가 DOM에서 마운트 해제될 때**마다 실행.
- 첫번째 사이드이펙트가 실행되기 전에는 실행되지 않는다는 뜻.

ex) 새로운 타이머를 설정하기 전에 마지막 타이머를 지우는 식.

---

## 디바운싱과 Cleanup 함수로 타이머 설정 및 타이머 클린업하기

1. `setTimeout(()=>{유효성 검사 동작}, 500)`

- 디바운싱
- 사용자가 새로 키 입력하여 타이머를 다시 시작하기까지는 500초 지연 시킨다.

2. Cleanup 함수 안에서 `clearTimeout(setTimeout 담은 변수)` 실행

- Cleanup 프로세스
- 새로운 타이머를 설정하기 전에 마지막 타이머를 지우는 역할.
- 다음 사이드이펙트를 실행할 때가 되면 새로운 타이머를 설정된다.

```JSX
useEffect(()=>{
  const identifier = setTimeout(()=>{
    //모든 키 입력에 대하여 한번만 실행된다.
    console.log('Checking from validity!');
    setFormIsValid(
enteredEmail.includes('@') &&
enteredPassword.trim().length > 6
);
  }, 500);


  return () => {
     clearTimeout(identifier);
  }
}, [enteredEmail, enteredPassword]);

const emailChangeHandler = (event) => {
  setEnteredEmail(event.target.value);
}
```
